{"ast":null,"code":"'use strict';\n\nvar createVisitor = require('./create_visitor'),\n    escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n/**\n * @class\n * @private\n */\n\n\nfunction Matcher(options) {\n  this.captures = options.captures;\n  this.re = options.re;\n}\n/**\n * Try matching a path against the generated regular expression\n * @param  {String} path The path to try to match\n * @return {Object|false}      matched parameters or false\n */\n\n\nMatcher.prototype.match = function (path) {\n  var match = this.re.exec(path),\n      matchParams = {};\n\n  if (!match) {\n    return;\n  }\n\n  this.captures.forEach(function (capture, i) {\n    if (typeof match[i + 1] === 'undefined') {\n      matchParams[capture] = undefined;\n    } else {\n      matchParams[capture] = decodeURIComponent(match[i + 1]);\n    }\n  });\n  return matchParams;\n};\n/**\n * Visitor for the AST to create a regular expression matcher\n * @class RegexpVisitor\n * @borrows Visitor-visit\n */\n\n\nvar RegexpVisitor = createVisitor({\n  'Concat': function (node) {\n    return node.children.reduce(function (memo, child) {\n      var childResult = this.visit(child);\n      return {\n        re: memo.re + childResult.re,\n        captures: memo.captures.concat(childResult.captures)\n      };\n    }.bind(this), {\n      re: '',\n      captures: []\n    });\n  },\n  'Literal': function (node) {\n    return {\n      re: node.props.value.replace(escapeRegExp, '\\\\$&'),\n      captures: []\n    };\n  },\n  'Splat': function (node) {\n    return {\n      re: '([^?]*?)',\n      captures: [node.props.name]\n    };\n  },\n  'Param': function (node) {\n    return {\n      re: '([^\\\\/\\\\?]+)',\n      captures: [node.props.name]\n    };\n  },\n  'Optional': function (node) {\n    var child = this.visit(node.children[0]);\n    return {\n      re: '(?:' + child.re + ')?',\n      captures: child.captures\n    };\n  },\n  'Root': function (node) {\n    var childResult = this.visit(node.children[0]);\n    return new Matcher({\n      re: new RegExp('^' + childResult.re + '(?=\\\\?|$)'),\n      captures: childResult.captures\n    });\n  }\n});\nmodule.exports = RegexpVisitor;","map":{"version":3,"sources":["/workspace/frontend/node_modules/route-parser/lib/route/visitors/regexp.js"],"names":["createVisitor","require","escapeRegExp","Matcher","options","captures","re","prototype","match","path","exec","matchParams","forEach","capture","i","undefined","decodeURIComponent","RegexpVisitor","node","children","reduce","memo","child","childResult","visit","concat","bind","props","value","replace","name","RegExp","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar createVisitor  = require('./create_visitor'),\n    escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n/**\n * @class\n * @private\n */\nfunction Matcher(options) {\n  this.captures = options.captures;\n  this.re = options.re;\n}\n\n/**\n * Try matching a path against the generated regular expression\n * @param  {String} path The path to try to match\n * @return {Object|false}      matched parameters or false\n */\nMatcher.prototype.match = function (path) {\n  var match = this.re.exec(path),\n      matchParams = {};\n\n  if( !match ) {\n    return;\n  }\n\n  this.captures.forEach( function(capture, i) {\n    if( typeof match[i+1] === 'undefined' ) {\n      matchParams[capture] = undefined;\n    }\n    else {\n      matchParams[capture] = decodeURIComponent(match[i+1]);\n    }\n  });\n\n  return matchParams;\n};\n\n/**\n * Visitor for the AST to create a regular expression matcher\n * @class RegexpVisitor\n * @borrows Visitor-visit\n */\nvar RegexpVisitor = createVisitor({\n  'Concat': function(node) {\n    return node.children\n      .reduce(\n        function(memo, child) {\n          var childResult = this.visit(child);\n          return {\n            re: memo.re + childResult.re,\n            captures: memo.captures.concat(childResult.captures)\n          };\n        }.bind(this),\n        {re: '', captures: []}\n      );\n  },\n  'Literal': function(node) {\n    return {\n      re: node.props.value.replace(escapeRegExp, '\\\\$&'),\n      captures: []\n    };\n  },\n\n  'Splat': function(node) {\n    return {\n      re: '([^?]*?)',\n      captures: [node.props.name]\n    };\n  },\n\n  'Param': function(node) {\n    return {\n      re: '([^\\\\/\\\\?]+)',\n      captures: [node.props.name]\n    };\n  },\n\n  'Optional': function(node) {\n    var child = this.visit(node.children[0]);\n    return {\n      re: '(?:' + child.re + ')?',\n      captures: child.captures\n    };\n  },\n\n  'Root': function(node) {\n    var childResult = this.visit(node.children[0]);\n    return new Matcher({\n      re: new RegExp('^' + childResult.re + '(?=\\\\?|$)' ),\n      captures: childResult.captures\n    });\n  }\n});\n\nmodule.exports = RegexpVisitor;"]},"metadata":{},"sourceType":"script"}