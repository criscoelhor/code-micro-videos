{"ast":null,"code":"'use strict';\n\nvar Parser = require('./route/parser'),\n    RegexpVisitor = require('./route/visitors/regexp'),\n    ReverseVisitor = require('./route/visitors/reverse');\n\nRoute.prototype = Object.create(null);\n/**\n * Match a path against this route, returning the matched parameters if\n * it matches, false if not.\n * @example\n * var route = new Route('/this/is/my/route')\n * route.match('/this/is/my/route') // -> {}\n * @example\n * var route = new Route('/:one/:two')\n * route.match('/foo/bar/') // -> {one: 'foo', two: 'bar'}\n * @param  {string} path the path to match this route against\n * @return {(Object.<string,string>|false)} A map of the matched route\n * parameters, or false if matching failed\n */\n\nRoute.prototype.match = function (path) {\n  var re = RegexpVisitor.visit(this.ast),\n      matched = re.match(path);\n  return matched ? matched : false;\n};\n/**\n * Reverse a route specification to a path, returning false if it can't be\n * fulfilled\n * @example\n * var route = new Route('/:one/:two')\n * route.reverse({one: 'foo', two: 'bar'}) -> '/foo/bar'\n * @param  {Object} params The parameters to fill in\n * @return {(String|false)} The filled in path\n */\n\n\nRoute.prototype.reverse = function (params) {\n  return ReverseVisitor.visit(this.ast, params);\n};\n/**\n * Represents a route\n * @example\n * var route = Route('/:foo/:bar');\n * @example\n * var route = Route('/:foo/:bar');\n * @param {string} spec -  the string specification of the route.\n *     use :param for single portion captures, *param for splat style captures,\n *     and () for optional route branches\n * @constructor\n */\n\n\nfunction Route(spec) {\n  var route;\n\n  if (this) {\n    // constructor called with new\n    route = this;\n  } else {\n    // constructor called as a function\n    route = Object.create(Route.prototype);\n  }\n\n  if (typeof spec === 'undefined') {\n    throw new Error('A route spec is required');\n  }\n\n  route.spec = spec;\n  route.ast = Parser.parse(spec);\n  return route;\n}\n\nmodule.exports = Route;","map":{"version":3,"sources":["/workspace/frontend/node_modules/route-parser/lib/route.js"],"names":["Parser","require","RegexpVisitor","ReverseVisitor","Route","prototype","Object","create","match","path","re","visit","ast","matched","reverse","params","spec","route","Error","parse","module","exports"],"mappings":"AAAA;;AACA,IAAIA,MAAM,GAAGC,OAAO,CAAC,gBAAD,CAApB;AAAA,IACIC,aAAa,GAAGD,OAAO,CAAC,yBAAD,CAD3B;AAAA,IAEIE,cAAc,GAAGF,OAAO,CAAC,0BAAD,CAF5B;;AAIAG,KAAK,CAACC,SAAN,GAAkBC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAH,KAAK,CAACC,SAAN,CAAgBG,KAAhB,GAAwB,UAASC,IAAT,EAAe;AACrC,MAAIC,EAAE,GAAGR,aAAa,CAACS,KAAd,CAAoB,KAAKC,GAAzB,CAAT;AAAA,MACIC,OAAO,GAAGH,EAAE,CAACF,KAAH,CAASC,IAAT,CADd;AAGA,SAAOI,OAAO,GAAGA,OAAH,GAAa,KAA3B;AAED,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAT,KAAK,CAACC,SAAN,CAAgBS,OAAhB,GAA0B,UAASC,MAAT,EAAiB;AACzC,SAAOZ,cAAc,CAACQ,KAAf,CAAqB,KAAKC,GAA1B,EAA+BG,MAA/B,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASX,KAAT,CAAeY,IAAf,EAAqB;AACnB,MAAIC,KAAJ;;AACA,MAAI,IAAJ,EAAU;AACR;AACAA,IAAAA,KAAK,GAAG,IAAR;AACD,GAHD,MAGO;AACL;AACAA,IAAAA,KAAK,GAAGX,MAAM,CAACC,MAAP,CAAcH,KAAK,CAACC,SAApB,CAAR;AACD;;AACD,MAAI,OAAOW,IAAP,KAAgB,WAApB,EAAkC;AAChC,UAAM,IAAIE,KAAJ,CAAU,0BAAV,CAAN;AACD;;AACDD,EAAAA,KAAK,CAACD,IAAN,GAAaA,IAAb;AACAC,EAAAA,KAAK,CAACL,GAAN,GAAYZ,MAAM,CAACmB,KAAP,CAAaH,IAAb,CAAZ;AACA,SAAOC,KAAP;AACD;;AAEDG,MAAM,CAACC,OAAP,GAAiBjB,KAAjB","sourcesContent":["'use strict';\nvar Parser = require('./route/parser'),\n    RegexpVisitor = require('./route/visitors/regexp'),\n    ReverseVisitor = require('./route/visitors/reverse');\n\nRoute.prototype = Object.create(null)\n\n/**\n * Match a path against this route, returning the matched parameters if\n * it matches, false if not.\n * @example\n * var route = new Route('/this/is/my/route')\n * route.match('/this/is/my/route') // -> {}\n * @example\n * var route = new Route('/:one/:two')\n * route.match('/foo/bar/') // -> {one: 'foo', two: 'bar'}\n * @param  {string} path the path to match this route against\n * @return {(Object.<string,string>|false)} A map of the matched route\n * parameters, or false if matching failed\n */\nRoute.prototype.match = function(path) {\n  var re = RegexpVisitor.visit(this.ast),\n      matched = re.match(path);\n\n  return matched ? matched : false;\n\n};\n\n/**\n * Reverse a route specification to a path, returning false if it can't be\n * fulfilled\n * @example\n * var route = new Route('/:one/:two')\n * route.reverse({one: 'foo', two: 'bar'}) -> '/foo/bar'\n * @param  {Object} params The parameters to fill in\n * @return {(String|false)} The filled in path\n */\nRoute.prototype.reverse = function(params) {\n  return ReverseVisitor.visit(this.ast, params);\n};\n\n/**\n * Represents a route\n * @example\n * var route = Route('/:foo/:bar');\n * @example\n * var route = Route('/:foo/:bar');\n * @param {string} spec -  the string specification of the route.\n *     use :param for single portion captures, *param for splat style captures,\n *     and () for optional route branches\n * @constructor\n */\nfunction Route(spec) {\n  var route;\n  if (this) {\n    // constructor called with new\n    route = this;\n  } else {\n    // constructor called as a function\n    route = Object.create(Route.prototype);\n  }\n  if( typeof spec === 'undefined' ) {\n    throw new Error('A route spec is required');\n  }\n  route.spec = spec;\n  route.ast = Parser.parse(spec);\n  return route;\n}\n\nmodule.exports = Route;"]},"metadata":{},"sourceType":"script"}